# Типы данных

## Фундаментальные типы 

### Целочисленные типы

- **int8**, **int16**, int32, **int64**, **int**

- **uint8**, **uint16**, **uint32**, uint64, **uint**

- **byte**: синоним типа **`uint8`**

- **rune**: синоним типа **`int32`**


### Числа с плавающей точкой(дробные)

- **float32**: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)
- **float64**: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт.

Тип **float32** обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом **float64**, составляет около 15 цифр. В качестве разделителя между целой и дробной частью применяется точка.

### Комплексные числа

- **complex64**: комплексное число, где вещественная и мнимая части представляют числа float32
- **complex128**: комплексное число, где вещественная и мнимая части представляют числа float64

### Тип bool

Логический тип или тип bool может иметь одно из двух значений: **true** (истина) или **false** (ложь).

### Строки

Строки же представляют собой **неизменяемый** последовательный набор байт **фиксированного размера**. Это означает, что вы не можете изменять строки — только создавать новые. Это важно понимать в контексте производительности программы. В программах, где нужна очень высокая производительность, постоянное создание большого количества строк создаст ощутимую нагрузку на сборщик мусора.

С юникод строками удобнее работать как со слайсами из **rune**

### Константы

Константы вычисляются на тапе компиляции и не меняются в рантайме. Имеют интересную систему типов(чуть отличающуюся от фундаментальных), имеют повышенную точность. Есть генератор констант **iota**.

### Значение по умолчанию

Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, для строк - ""(пустая строка).

## Составные

### Массив

По определению тип массива состоит из длины и типа его элементов. Например, тип `[4]int` представляет массив из четырёх целых чисел. Размер массива неизменяем; его *длина - это часть его типа* (`[4]int` и `[5]int` различные, несовместимые типы). Массивы могут быть проиндексированы, поэтому с помощью выражения `s[n]` мы получаем доступ к n-ному элементу, начиная с нуля. Массивы не нужно инициализировать явно; нулевой массив - это готовый к использованию массив, элементы которого являются нулями:

```go
var a [4]int
a[0] = 1
// a[2] == 0, нулевое значение типа int
```



Представление [4]int в памяти - это просто четыре целых значения, расположенных последовательно:

<img src="../media/go/slice-array.png" max-width="100%"/>

Массивы в Go и есть значения. Переменная с именем массива обозначает весь массив; это не указатель на первый элемент (как это было бы в случае С). Это значит, что когда вы присваиваете значение или проходитесь по массиву, вы будете делать копию его содержимого (для избежания копирования, вы могли бы передавать указатель на массив, но тогда это будет указатель на него, а не сам массив). 

Литерал массива может быть задан так + можете указать компилятору посчитать количество значений:

```go
b := [2]string{"Penn", "Teller"}
с := [...]string{"Penn", "Teller"}
```

### Слайсы

Слайс - это дескриптор сегмента массива. Он состоит из указателя на массив, длины сегмента и его вместимости (максимальной длины сегмента).

```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

Наша переменная `s`, созданная ранее с помощью `make([]byte, 5)`, имеет такую структуру:



<img src="../media/go/slice-1.png" max-width="100%"/>

Длина - это число элементов, на которое ссылается слайс. Вместимость - это число элементов лежащего в основе массива (начиная с элемента, на который ссылается указатель слайса). Разница между длиной и вместимостью станет чётче по ходу знакомства с остальными примерами.

По мере изменения промежутков слайса, можно наблюдать изменения в структуре данных слайса и их отношениях с лежащим в основе массивом:

![Изображены три вертикальных клетки и пять горизонтальных. В первой клетке указатель на массив типа [5]byte, в двух других len и cap, равные 2 и 3 соответственно. Указатель показывает на третью клетку массива (у которой индекс равен 2)](https://blog.golang.org/go-slices-usage-and-internals_slice-2.png)

Слайсниг не производит копирование данных слайса. Создаётся новое значение слайса, указывающее на исходный массив. Это делает операцию слайсинга такой же эффективной, как и манипуляции с индексами массива. Таким образом, изменение элементов (не самого слайса) нового слайса изменяет элементы исходного:

```go
d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
```

Ранее мы слайсили `s` до длины, меньшей, чем вместимость. Мы можем увеличить `s` до её вместимости, сделав слайсинг снова. Слайс нельзя сделать большим, чем его вместимость. Если вы попытаетесь, это вызовет панику времени выполнения, как и когда происходит обращение к индексу вне границ слайса или массива.

## Увеличение слайсов (функции copy и append)

Для увеличения вместимости слайса необходимо создать новый, более крупный слайс и скопировать элементы исходного слайса в него. Эта техника показывает, как реализуются динамические массивы в других языках. Следующий пример удваивает вместимость `s`, создавая новый слайс `t`, копируя содержимое `s` в `t`, а затем присваивая `s` значение слайса `t`:

```go
t := make([]byte, len(s), (cap(s)+1)*2) // +1 в случае cap(s) == 0
for i := range s {
        t[i] = s[i]
}

s = t
```

Повторяющаяся часть этой часто используемой операции реализована с помощью простой встроенной функции `copy`. Как подсказывает её имя, эта функция копирует данные из слайса-источника в слайс-приёмник. Возвращается количество скопированных элементов.

```go
func copy(dst, src []T) int
```

Функция `copy` поддерживает копирование между слайсами разной длины (она скопирует только до меньшего числа элементов). К тому же, `copy` может справиться со слайсами, относящимися к одному массиву в основе этих слайсов, работая правильно с перекрытием слайсов.

Используя `copy`, можно упростить кусочек кода выше:

```go
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
```

Часто необходимо добавить данные в конец слайса. Эта функция добавляет элементы в байтовый слайс, увеличивая сам слайс по необходимости, и возвращает обновлённый слайс:

```go
func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n > cap(slice) { // если нужно, перераспределить память
        // выделяем в два раза больше нужного, для увеличения в будущем
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
```

Можно было бы использовать AppendByte таким образом:

```go
p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
```

Такие функции, как AppendByte, полезны, потому что они предоставляют полный контроль над способом увеличения слайсов. В зависимости от характеристики программы может понадобиться создание более маленького или большого слайса, или загрузить слайс элементами до предельного размера памяти.

Хотя большинству программ не нужен абсолютный контроль, поэтому Go предоставляет встроенную функцию `append`, которая хорошо подходит в большинстве случаев. Она имеет такую сигнатуру:

```go
func append(s []T, x ...T) []T
```

Эта функция добавляет элементы в конец слайса `s` и увеличивает вместимость, если нужно.

```go
a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
```

Чтобы добавить один слайс в другой, используйте `…` в качестве второго аргумента, чтобы он стал списком аргументов.

```go
a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // то же самое, что и "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}
```

Так как нулевой слайс работает как слайс нулевой длины, вы можете объявить переменную со слайсом и затем циклично добавлять в неё элементы:

```go
// Filter возвращает новый слайс,
// из элементов s, удовлетворяющих условиям функции f()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}
```

## Возможная ловушка

Как говорилось ранее, переслайсинг (re-slicing) среза не создаёт копию массива в основании. Массив полностью будет существовать в памяти, пока на него не перестанут ссылаться. Иногда это вызывает хранение всех данных в памяти, когда нужна только их небольшая часть.

Например, функция `FindDigits` загружает файл в память и ищет в нём первую группу последовательных цифр, возвращая их в новом слайсе.

```go
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
```

Этот код работает, как и говорилось, однако возвращаемый срез `[]byte` указывает на массив, содержащий файл целиком. Так как слайс ссылается на исходный массив, пока слайс есть в памяти, сборщик мусора не сможет очистить массив; несколько важных байтов файла держат всё содержимое в памяти.

Чтобы исправить это, можно скопировать интересующие нас данные в новый слайс до того, как вернуть значение.

```go
func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
```

###  Map

Отображение или map представляет ссылку на хеш-таблицу - структуру данных, где каждый элемент представляет пару "ключ-значение". При этом каждый элемент имеет уникальный ключ, по которому можно получить значение элемента. Отображение определяется как объект типа map[K]V, где К представляет тип ключа, а V - тип значения. Причем тип ключа K должен поддерживать операцию сравнения ==, чтобы оображение могло сопоставить значение с одним из ключей и хеш-таблицы.

```go
// A header for a Go map.
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}
```

Например, определение отображения, которое в качестве ключей имеет тип string, а в качестве значений - тип int:

```go
var people map[string] int   
// Ключи представляют тип string, значения - тип int`
```

Для проверки наличия элемента по определенному ключу можно применять выражение if. Если значение по заданному ключу имеется в отображении, то переменная ok будет равна true, а переменная val будет хранить полученное значение. Если переменная ok равна false, то значения по ключу в отображении нет.

```go
	var people = map[string]int{"Tom": 1, "Bob": 2, "Sam": 4, "Alice": 8}

	if val, ok := people["Tom"]; ok {
		fmt.Println(val)
	}
```

Адрес элемента мапы получить невозможно(сделано из за того что адрес может стать недействителен, после рехеширования)

```go
_ = &ages["bob"] // ТАК НЕЛЬЗЯ!!!
```

### Структра

Структура — составной тип, содержащий именованные поля. Также поддерживается встраивание структур в качестве анонимного поля(как способ реализации композиции). К полям и методам встроенных структур можно обращаться как черзе них, так и через "родительскую".

## Интерфейсы 

```go
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32 // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}

type interfacetype struct {
	typ     _type
	pkgpath name
	mhdr    []imethod
} 

//пустой интерфейс interface{}
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.

Для определения интерфейса применяется ключевое слово interface:

```go
type имя_интерфейса interface {определения_функций()}
```

### Nill interface vs nil pointer interface

<img src="https://habrastorage.org/files/ac9/905/1fb/ac99051fbb924e6d8912f479915b7a78.png" width="100%">