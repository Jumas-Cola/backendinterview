# Планировщик

Выделяют 3 модели для нарезания вычисления на потоки. 

Первой является **N:1**, где несколько пользовательских потоков запущено на едином потоке ядра операционной системы. Этот способ имеет то преимущество, что осуществляется очень быстрое переключение контекстов, но нет возможности воспользоваться преимуществами многоядерных систем. 

Вторая — это **1:1**, где каждый пользовательский поток выполнения совпадает с одним потоком операционной системы. Он использует все ядра автоматически, но переключение контекста происходит медленно, потому что требует прерываний работы операционной системы.

Go пытается взять лучшее из обоих миров с помощью **М:N** планировщика. При этом произвольное число Go-рутин (**M**) планируется на произвольное количество потоков (**N**) операционной системы. Этим вы получаете одновременно быстрое переключение контекста, и возможность воспользоваться всеми ядрами в вашей системе. Основным недостатком данного подхода является сложность его включения в планировщик.  

 Чтобы исполнять задачу планирования, планировщик Go использует 3 основных сущностей:

![img](../media/go/scheduler_mpg.jpeg)

**Треугольник представляет поток** операционной системы. Выполнением такого потока управляет операционная система, и работает это во многом подобно вашим стандартным потокам POSIX. В исполнимом коде это называется **M машиной**.

**Круг представляет Go-рутину.** Он включает стек, указатель команд и другую важную информацию для планирования Go-рутины, такую как канал, который на ней может быть блокирован. В исполнимом коде это обозначается как **G**.

**Прямоугольник представляет контекст планирования**. Вы можете понимать его как локализованная версию планировщика, который выполняет код Go-рутин в единственном потоке ядра. **Это важная часть, которая позволяет нам уйти от N:1 планировщика к М:N планировщику.** Во время выполнения кода контекст обозначается как **P для процессора**. В общем это и всё, если коротко.

![img](../media/go/scheduler_mpg2.jpeg)



В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (**GRQ**) и локальная очередь выполнения (**LRQ**). Каждому **P** присваивается **LRQ**, который управляет горутинами, назначенными для выполнения в контексте **P**. Эти горутины по очереди включаются и выключаются из контекста **M**, назначенного для этого **P**. **GRQ** предназначен для горутин, которые не были назначены для **P**. Существует процесс, чтобы переместить горутины из **GRQ** в **LRQ**

![img](../media/go/scheduler_grq_lrq.png)



##  

work stealing

Вытесняющая многозадачность